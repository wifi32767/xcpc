## STL
### string
```c++
string s1 (5, 's'); //s1 = "sssss"
s1.size()
string s2 = "1234567890";
s2.insert(5, "bbb"); //s2 = "12345bbb67890"
string 3 = s4 = "1234567890";
s3.erase(5); //s3 = "12345"
s4.erase(5, 3); //s4 = "1234590"
string s5 = s2.substr(5); //s5 = "bbb67890"
string s6 = s2.substr(5, 3); //s6 = "bbb"
string s7 = "first second third";
string s8 = "second";
int index = s7.find(s8, 5); //第二个参数是开始查找的位置
//index = 6
index = s7.rfind(s8, 6); //最多查找到第二个参数
//index = 6
```
find()方法查找不到这个元素的时候会返回string::npos
### set
```c++
// 相当于一个从小到大排序的序列，每次插入元素相当于会自动排序
set<int> s; // 元素不能重复的平衡树
multiset<int> s; // 元素能重复的平衡树
s.insert(3); // 插入一个元素，在set中，插入已有元素的操作会无效
s.erase(3); // 删除一个元素，在multiset中。会删除所有的该元素
set<int>::iterator it; // set的迭代器，相当于访问set中元素的指针
multiset<int>::iterator it; // multiset的迭代器
it = s.begin(); // 获取第一个元素（最小的元素）
it = s.end(); // 获取终止迭代器，位于最后一个元素之后
it = s.rbegin(); // 获取最后一个元素（最大的元素）
it = s.lower_bound(3), it = s.upper_bound(2); // 见二分查找
it ++; // 让it指向下一个元素
it --; // 让it指向上一个元素
if(s.find(3) != s.end()) // 判断元素是否存在
s.erase(s.find(3)); // 用于multiset中删除一个指定元素
s.erase(it ++); // 用于删除it并且让it指向下一个元素
a = *it; // 取值
for (set<int>::iterator it = s.begin(); it != s.end(); it ++) // 遍历
for (auto &i : s) // 遍历所有数值
```
### map
```c++
map<string,int> maps; //第一个是键的类型，第二个是值的类型
maps['c'] = 5; //通过下标进行访问
//map可以使用it->first来访问键，使用it->second访问值
for (auto it : mp) {
    cout << it.first << " " << it.second << endl;
}
// 定义一个map对象
map<int, string> m;
//用insert函数插入pair
m.insert(pair<int, string>(111, "kk"));
//用find函数查找元素
map<string,int> :: iterator it;
it = maps.find("123"); //返回的是迭代器
//迭代器刪除
it = maps.find("123");
maps.erase(it);
//erase关键字删除
int n = maps.erase("123"); //如果删除了返回1，否则返回0
//用迭代器范围删除 : 把整个map清空
maps.erase(maps.begin(), maps.end());
```
### 二分查找
```c++
int *p = lower_bound(a + 1, a + n + 1, x); // 在a[1]到a[n]中找到大于等于x的第一个数的地址
int p = lower_bound(a + 1, a + n + 1, x) - a; // 获取下标
int *p = upper_bound(a + 1, a + n + 1, x); // 在a[1]到a[n]中找到大于x的第一个数的地址
int p = upper_bound(a + 1, a + n + 1, x) - a; // 获取下标
```
## 字符串
### KMP
```c++
vector<int> kmp(string s1, string s2){
    int l1 = s1.size(), l2 = s2.size();
    s1 = ' ' + s1;
    s2 = ' ' + s2;
    vector<int> nex(l2 + 1), ans;
    int j = 0;
    for (int i = 2; i <= l2; ++ i){
		while (j and s2[i] != s2[j + 1]) j = nex[j];
		if (s2[i] == s2[j + 1]) j ++;
		nex[i] = j;
    }
    j = 0;
    for (int i = 1; i <= l1; ++ i){
        while (j and s1[i] != s2[j + 1]) j = nex[j];
        if (s1[i] == s2[j + 1]) j ++;
        if (j == l2) ans.push_back(i - j + 1), j = nex[j];
    }
    return ans;
}
```
### 字典树
```c++
struct TRIE{
    static const int M = 3e6 + 10, N = 65;
    int size;
    vector<vector<int>> tree; //如果使用数组，那么空间开太大会出某种事故
    vector<int> cnt;
    TRIE(){
        cnt.resize(M);
        tree.resize(M);
        tree[0].resize(N);
    }
    void clear(){
        for (int i = 0; i < this->size; ++ i){
            cnt[i] = 0;
            for (int j = 0; j < N; ++ j) tree[i][j] = 0;
        }
        this->size = 0;
    }
    int getnum(char ch){ //映射字符
        if ('a' <= ch && ch <= 'z') return ch - 'a';
        else if ('A' <= ch && ch <= 'Z') return ch - 'A' + 26;
        else return ch - '0' + 52;
    }
    void insert(string &s){
        int len = s.size(), cur = 0;
        for (int i = 0; i < len; i ++ ){
            int c = getnum(s[i]);
            if (!tree[cur][c]){
                tree[cur][c] = ++ this->size;
                tree[this->size].resize(N);
            }
            cur = tree[cur][c];
        }
        cnt[cur] ++;
    }
    int find(string &s){
        int len = s.size(), cur = 0;
        for (int i = 0; i < len; i ++ ){
            int c = getnum(s[i]);
            if (!tree[cur][c]) return 0;
            cur = tree[cur][c];
        }
        return cnt[cur];
    }
};
```
### 字符串哈希
```c++
struct Hash{ //这个模板要对下标从1开始的字符串使用才正常
    const ull P = 11037;
    int n;
    vector<ull> p, h1;
    void init(string &s){
        n = s.size() - 1;
        p.resize(n + 2), h1.resize(n + 2);
        p[0] = 1; h1[0] = 0;
        for(int i = 1 ; i <= n ; i ++) p[i] = p[i - 1] * P;
        for(int i = 1 ; i <= n ; i ++) h1[i] = h1[i - 1] * P + s[i];
    }
    ull get(int l, int r) { 
        return h1[r] - h1[l - 1] * p[r - l + 1];
    }
};
```
### 二维字符串哈希
```c++
struct Hash{ //下标从1开始
    const ull p1 = 131, p2 = 1331; //两个底数不能一样
    int n, m;
    vector<vector<ull>> h;
    vector<ull> b1, b2;
    void init(vector<string> &g){
        n = g.size() - 1, m = g.back().size();
        b1.resize(n + 1);
        b2.resize(m + 1);
        b1[0] = b2[0] = 1;
        for (int i = 1; i <= n; ++ i) b1[i] = b1[i - 1] * p1;
        for (int i = 1; i <= m; ++ i) b2[i] = b2[i - 1] * p2;
        h.resize(n + 1);
        for (int i = 0; i <= n; ++ i) h[i].resize(m + 1);
        for (int i = 1; i <= n; ++ i){
            for (int j = 1; j <= m; ++ j){
                h[i][j] = h[i][j - 1] * p1 + (int)(g[i][j - 1]);
            }
        }
        for (int j = 1; j <= m; ++ j){
            for (int i = 1; i <= n; ++ i){
                h[i][j] += h[i - 1][j] * p2;
            }
        }
    }
    ull get(int x1, int y1, int x2, int y2){
        return h[x2][y2] - h[x1 - 1][y2] * b2[x2 - x1 + 1] - h[x2][y1 - 1] * b1[y2 - y1 + 1] + h[x1 - 1][y1 - 1] * b1[y2 - y1 + 1] * b2[x2 - x1 + 1];
    }
};
```
### Manacher(马拉车)
给定一个长为 n 的字符串 s，找到所有对 (i,j) 使 s[i:j] 为回文串  
Manacher 可以在 $O(n)$ 时间解决这个问题
```c++
n = s.size();
//奇数长度的回文串有中心点，偶数长度没有，因此两者有些许区别
vector<int> d1(n); //d1[i]表示i的回文半径
for (int i = 0, l = 0, r = -1; i < n; i ++ ){
    int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
    while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k ++;
    d1[i] = k --;
    if (i + k > r) l = i - k, r = i + k;
}
vector<int> d2(n); //d2[i]表示以i-1与i之间的空隙为中心的回文半径
for (int i = 0, l = 0, r = -1; i < n; i ++ ){
    int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
    while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k ++;
    d2[i] = k--;
    if (i + k > r) l = i - k - 1, r = i + k;
}
```
### AC自动机
```c++
struct ACAM{
    static const int M = 2e5 + 10, N = 26;
    int size;
    int tree[M][N];
    int cnt[M], fail[M];
    void clear(){
        for (int i = 0; i <= this->size; ++ i){
            cnt[i] = fail[i] = 0;
            for (int j = 0; j < N; ++ j) tree[i][j] = 0;
        }
        this->size = 0;
    }
    int getnum(char ch){ //映射字符
        if ('a' <= ch && ch <= 'z') return ch - 'a';
    }
    void insert(string &s){
        int len = s.size(), cur = 0;
        for (int i = 0; i < len; ++ i){
            int c = getnum(s[i]);
            if (!tree[cur][c]){
                tree[cur][c] = ++ this->size;
            }
            cur = tree[cur][c];
        }
    }
    int find(string s){
        int len = s.size(), cur = 0;
        for (int i = 0; i < len; ++ i){
            int c = getnum(s[i]);
            if (!tree[cur][c]) return 0;
            cur = tree[cur][c];
        }
        return cnt[cur];
    }
	void getfail(){
		queue<int> que; //对字典树进行bfs
		for (int i = 0; i < N; ++ i){
			if (tree[0][i]){
				fail[tree[0][i]] = 0;
				que.push(tree[0][i]);
			}
		}
		while (!que.empty()){
			int cur = que.front(); que.pop();
			for (int i = 0; i < N; ++ i){
				if (tree[cur][i]){
					//一个节点的失配指针是其父亲的失配指针配这个节点到达的地方
					fail[tree[cur][i]] = tree[fail[cur]][i];
					que.push(tree[cur][i]); 
				}
				else tree[cur][i] = tree[fail[cur]][i]; //匹配失败就跳到失配指针
			}
		}
	}
	void ac_find(string s){
		int len = s.size(), cur = 0;
		for (int i = 0; i < len; ++ i){
			int c = getnum(s[i]);
			cur = tree[cur][c];
			cnt[cur] ++;
		}
		vector<int> in(MAX);
		for (int i = 1; i <= this->size; ++ i){
			in[fail[i]] ++;
		}
		queue<int> que;
		for (int i = 1; i <= this->size; ++ i){
			if (in[i] == 0) que.push(i);
		}
		while (not que.empty()){
			cur = que.front(); que.pop();
			cnt[fail[cur]] += cnt[cur];
			if (-- in[fail[cur]] == 0) que.push(fail[cur]);
		}
	}
};
```
### 后缀数组
```c++
string s;
int rk[MAX << 1], sa[MAX << 1], tmp[MAX << 1], cnt[MAX], rkt[MAX];
void init_sa(){ //以1为下标起点，n为字符串长度
    if (n == 1) return void(rk[1] = sa[1] = 1);
    int m = 128;
    for (int i = 1; i <= n; ++ i)
        cnt[rk[i] = s[i]] ++;
    for (int i = 1; i <= m; ++ i)
        cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; -- i)
        sa[cnt[rk[i]] --] = i;
    for (int w = 1;; w <<= 1) {
        for (int i = n; i > n - w; -- i)
            tmp[n - i + 1] = i;
        for (int i = 1, p = w; i <= n; ++ i)
            if (sa[i] > w) tmp[++ p] = sa[i] - w;
        fill(cnt + 1, cnt + m + 1, 0);
        for (int i = 1; i <= n; ++i)
            cnt[rkt[i] = rk[tmp[i]]] ++;
        for (int i = 1; i <= m; ++i)
            cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i)
            sa[cnt[rkt[i]]--] = tmp[i];
        m = 0;
        auto rp = [&](int x) { return make_pair(rk[x], rk[x + w]); };
        for (int i = 1; i <= n; ++i)
            tmp[sa[i]] = rp(sa[i - 1]) == rp(sa[i]) ? m : ++m;
        copy(tmp + 1, tmp + n + 1, rk + 1);
        if (n == m) break;
    }
}
int ht[MAX];
void init_ht(){
    for (int i = 1, k = 0; i <= n; ++ i){
        if (rk[i] == 0) continue;
        if (k) k --;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k ++;
        ht[rk[i]] = k;
    }
}
```
### 回文自动机
```c++
struct PAM{
    int size, tot, cur, n;
    int cnt[MAX], tree[MAX][26], len[MAX], fail[MAX], s[MAX];
    int node(int l){  //建立一个新节点，长度为l
        size ++;
        memset(tree[size], 0, sizeof(tree[size]));
        len[size] = l;
        fail[size] = cnt[size] = 0;
        return size;
    }
    int getfail(int x){  //找后缀回文
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void add(char ch){
		int c = ch - 'a';
        s[++ tot] = c;
        int now = getfail(cur);
        if (!tree[now][c]){
            int x = node(len[now] + 2);
            fail[x] = tree[getfail(fail[now])][c];
            tree[now][c] = x;
        }
        cur = tree[now][c];
        cnt[cur] ++;
    }
    void init(string a){  //初始化
        size = -1; cur = 0;
        s[tot = 0] = -1;
        node(0); node(-1);
        fail[0] = 1;
		n = a.size() - 1;
		for (int i = 1; i <= n; ++ i) add(a[i]);
    }
	void solve(){
		for (int i = size; i >= 2; -- i){
			cnt[fail[i]] += cnt[i];
		}
	}
};
```
### 扩展KMP(Z函数)
z[i] 表示 s 与 s[i:n-1] 的最长公共前缀的长度
```c++
//这个算法默认z[0] = 0
vector<int> z_function(string s){
    int n = s.size();
    vector<int> z(n);
    int l = 0, r = 0;
    for (int i = 1; i < n; i ++ ){
        if (i <= r && z[i - l] < r - i + 1) z[i] = z[i - l];
        else{
            z[i] = max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i] ++;
        }
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}
```
### 最小表示法
当字符串 s 中存在一个位置满足 $s[i+1:n] + s[1:i] = t$ ，则称 s 与 t 循环同构
字符串 s 的最小表示为与 s 循环同构的字符串中字典序最小的一个
时间复杂度$O(n)$
```c++
int min_show(){
    int k = 0, i = 0, j = 1;
    while (k < n && i < n && j < n){
        if (sec[(i + k) % n] == sec[(j + k) % n]) k ++;
        else{
            sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
            if (i == j) i ++ ;
            k = 0;
        }
    }
    return min(i, j);
}
```
### Lyndon分解
对于字符串 s，如果 s 的字典序严格小于 s 的所有后缀的字典序，我们称 s 是简单串，或者 Lyndon 串。
串 s 的 Lyndon 分解记为 $s=w_1w_2… w_k$ ，其中所有 $w_i$ 为简单串，并且他们的字典序按照非严格单减排序，即 $w_1\ge w_2\ge…\ge w_k$ 。可以发现，这样的分解存在且唯一。
Duval 算法可以在 $O(n)$ 时间求出一个串的 Lyndon 分解
```c++
vector<string> duval(string s){
    int n = s.size(), i = 0;
    vector<string> ans;
    while (i < n){
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]){
            if (s[k] < s[j]) k = i;
            else k ++;
            j ++;
        }
        while (i <= k){
            ans.push_back(s.substr(i, j - k));
            i += j - k;
        }
    }
    return ans;
}
```
## 数据结构
### ST表
ST表用于解决可重复贡献问题，不支持修改操作  
```c++
for (int i = 1; i <= n; ++ i) cin >> st[i][0];
for (int i = 1; i < 20; ++ i){
    for(int j = 1; j + (1 << i) - 1 <= n; ++ j){
        st[j][i] = max(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);
    }
}
int k = log2(r - l + 1);
// l到r的最大值为 max(st[l][k], st[r - (1 << k) + 1][k]);
```
### 树状数组
```c++
struct BIT{ //单点更新，区间查询
    int n;
    vector<ll> sum;
	BIT(const int &n = 0) : n(n + 5), sum(n + 10){}
    int lowbit(int x){
        return x & (-x);
    }
    void add(int pos, ll val){
        for (; pos <= n; pos += lowbit(pos))
            sum[pos] += val;
    }
    ll query(int pos){
        ll res = 0;
        for (; pos > 0; pos -= lowbit(pos))
            res += sum[pos];
        return res;
    }
    ll query(int l, int r){
        return query(r) - query(l - 1);
    }
};
struct BIT{ //区间更新，单点查询
    int n;
    vector<ll> sum;
	BIT(const int &n = 0) : n(n + 5), sum(n + 10){}
    int lowbit(int x){
        return x & (-x);
    }
    void add(int pos, ll val){
        for (; pos <= n; pos += lowbit(pos))
            a[pos] += val;
    }
    void add(int l, int r, ll val){
        add(l, val);
        add(r + 1, -val);
    }
    ll query(int pos){
        ll res = 0;
        for (; pos > 0; pos -= lowbit(pos))
            res += a[pos];
        return res;
    }
};
struct BIT{ //区间更新，区间查询
    int n;
    vector<ll> a, b;
	BIT(const int &n = 0) : n(n + 5), a(n + 10), b(n + 10){}
    int lowbit(int x){
        return x & (-x);
    }
    void add(int pos, ll val){
        int x = pos;
        for(; pos <= n; pos += lowbit(pos)){
            a[pos] += val;
            b[pos] += val * (x - 1);
        }
    }
    void add(int l, int r, ll val){
        add(l, val);
        add(r + 1, -val);
    }
    ll query(int pos){
        int x = pos;
        ll res = 0;
        for (; pos > 0; pos -= lowbit(pos))
            res += x * a[pos] - b[pos];
        return res;
    }
    ll query(int l,int r){
        return query(r) - query(l - 1);
    }
};
//二维树状数组
//对于128MB的空间限制
//int二维树状数组的最大大小在2500 * 2500左右
//ll二维树状数组的最大大小在1800 * 1800左右
struct preBIT{
    int n, m;
    vector<vector<int>> sum;

    int lowbit(int x){
        return x & (-x);
    }
    preBIT(const int &n = 0, const int &m = 0) : n(n), m(m){
		sum = vector<vector<int>>(n + 1, vector<int>(m + 1));
	}
    void add(int x, int y, int val){
        int tmp = y;
        for (; x <= n; x += lowbit(x))
            for (y = tmp; y <= m; y += lowbit(y))
                sum[x][y] += val;
    }
    int query(int x, int y){
        int res = 0, tmp = y;
        for (; x > 0; x -= lowbit(x))
            for (y = tmp; y > 0; y -= lowbit(y))
                res += sum[x][y];
        return res;
    }
    int query(int x1, int y1, int x2, int y2){
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};
struct BIT{
	int n, m;
	preBIT bit[4];
	BIT(const int &n = 0, const int &m = 0) : n(n), m(m){
		for (int i = 0; i < 4; ++ i) bit[i] = preBIT(n, m);
	}
	void add(int x, int y, int val){
		bit[0].add(x, y, val);
		bit[1].add(x, y, val * x);
		bit[2].add(x, y, val * y);
		bit[3].add(x, y, val * x * y);
	}
	void add(int x1, int y1, int x2, int y2, int val){
		add(x1, y1, val);
        add(x1, y2 + 1, -val);
        add(x2 + 1, y1, -val);
        add(x2 + 1, y2 + 1, val);
	}
	int query(int x, int y){
		return bit[0].query(x, y) * (x * y + x + y + 1)
		- bit[1].query(x, y) * (y + 1)
		- bit[2].query(x, y) * (x + 1)
		+ bit[3].query(x, y);
	}
	int query(int x1, int y1, int x2, int y2){
		return query(x2, y2)
		- query(x1 - 1, y2)
		- query(x2, y1 - 1)
		+ query(x1 - 1,y1 - 1);
	}
};
//树状数组维护不可差分信息，这种做法的复杂度为log^2，劣于线段树
//以RMQ为例
struct BIT{
    int n;
    vector<int> a, b;
	BIT(const int &n = 0) : n(n), a(n), b(n){}
    int lowbit(int x){
        return x & (-x);
    }
    void update(int pos, int val){
		a[pos] = val;
		while (pos <= n){
            //对于每个受影响的位置x，都要重构一遍b[x]
            //具体来说，就是合并它的儿子与a[x]
			b[pos] = a[pos];
			int lx = lowbit(pos);
			for (int i = 1; i < lx; i <<= 1)
				b[pos] = max(b[pos], b[pos - i]);
			pos += lowbit(pos);
		}       
    }
    int query(int l, int r){
		int ans = 0;
		while (r >= l){
			ans = max(a[r], ans);
			r --;
            //判断下一次要跳到的位置r - lowbit(r)是否小于l
            //如果小于，合并a[r]单点，并跳到r - 1
            //否则合并b[r]，跳到r - lowbit(r)
			for (; r - lowbit(r) >= l; r -= lowbit(r))
				ans = max(b[r], ans);
		}
		return ans;
    }
};
//实际使用中发现这个板子会RE，因此谨慎使用
```
### 01字典树
```c++
```
### 可回滚并查集
```c++
struct DSU{
    int n = 0, cnt = 0, pre[MAX], sz[MAX], s[MAX];
    void init(int siz){
        n = siz;
        for (int i = 1; i <= n; ++ i) sz[i] = 1, pre[i] = i;
    }
    int find(int x){return pre[x] == x ? x : find(pre[x]);}
    void merge(int x, int y){
        x = find(x), y = find(y);
        if (x == y) return;
        if (sz[x] < sz[y]) swap(x, y);
        s[++ cnt] = y, pre[y] = x, sz[x] += sz[y];
    }
    void pop(){
        if (not cnt) return;
        int y = s[cnt --]; sz[pre[y]] -= sz[y], pre[y] = y;
    }
	int history(){return cnt;}
    void roll(int t = 0){while(cnt > t) pop();}
};
```
## 数学
### 开根
```c++
ll safe_sqrt(ll x){
    ll lk = 0, rk = 2 * sqrt(x);
    while (lk < rk){
        ll mid = (lk + rk) >> 1;
        if (mid * mid >= x) rk = mid;
        else lk = mid + 1;
    }
    return lk;
}
```
### 欧拉筛(线性筛)
```c++
int notPrime[MAX];
vector<int> primes;
void euler(int n){
    for (int i = 2; i <= n; ++ i){
        if (!notPrime[i]) primes.push_back(i);
        for (int j: primes){
            if (i * j > n) break;
            notPrime[j * i] = 1;
            if (i % j == 0) break;
        }
    }
}
```
### 求单个欧拉函数
```c++
int euler_phi(int n) {
    int ans = n;
    for (int i = 2; i * i <= n; ++ i){
        if (n % i == 0){
            ans = ans / i * (i - 1);
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) ans = ans / n * (n - 1);
    return ans;
}
```
### 筛法求欧拉函数
```c++
int primes[MAX], notPrime[MAX], phi[MAX];
void pre(){
    int cnt = 0;
    notPrime[1] = 1;
    phi[1] = 1;
    for (int i = 2; i <= MAX; ++ i) {
        if (!notPrime[i]){
            primes[cnt ++] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i * primes[j] <= MAX; ++ j) {
            notPrime[i * primes[j]] = 1;
            if (i % primes[j]) phi[i * primes[j]] = phi[i] * phi[primes[j]];
            else{
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
        }
    }
}
```
### 整除分块
用于求解 $\sum^{n}_{i=1}{\frac{n}{i}}$
```c++
ll division_block(ll n){
    ll res = 0;
    for(ll l = 1, r; l <= n; l = r + 1){
        r = n / (n / l);
        res += n / l * (r - l + 1);
    }
    return res;
}
```
### gcd最大公约数
```c++
int gcd(int x, int y){
    return (y == 0) ? (x) :(gcd(y, x % y));
}
```
### lcm最小公倍数
```c++
int lcm(int x, int y){
    return x * y / gcd(x, y);
}
```
### power快速幂
```c++
ll power(ll x, int y){
    ll ans = 1;
    while (y){
        if (y & 1) ans *= x, ans %= mod;
        x *= x, x %= mod;
        y >>= 1;
    }
    return ans;
}
```
### 预处理阶乘及逆元求组合数
```c++
ll fac[MAX], inv[MAX];
void init(int n){
    fac[0] = 1;
    for (int i = 1; i <= n; ++ i) fac[i] = fac[i - 1] * i % mod;
    inv[n] = power(fac[n], mod - 2);
    for (int i = n; i >= 1; i -- ) inv[i - 1] = inv[i] * i % mod;
}
ll cal(int x, int y){
    if (y > x) return 0;
    return (fac[x] * inv[y] % mod) * inv[x - y] % mod;
}
```
### 线性求逆元
```c++
int s[MAX], sv[MAX], inv[MAX];
s[0] = 1;
for (int i = 1; i <= n; ++ i) s[i] = s[i - 1] * a[i] % p;
sv[n] = power(s[n], mod - 2);
for (int i = n; i >= 1; -- i) sv[i - 1] = sv[i] * a[i] % p;
for (int i = 1; i <= n; ++ i) inv[i] = sv[i] * s[i - 1] % p;
```
### 拓展欧几里得
可以求解 $ax+by=gcd(a,b)$ 的一组特解  
该方程的通解：  
$\begin{cases} x_k=x+k\cdot\frac{b}{gcd(a,b)}\\ y_k=y-k\cdot\frac{a}{gcd(a,b)}\end{cases}$ 
```c++
ll exgcd(ll a, ll b, ll &x, ll &y){
    if (b == 0){
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}
```
函数的返回值是 $gcd(a,b)$
### 中国剩余定理
```c++
ll crt(vector<ll> a, vector<ll> r){ //a是余数，r是模数
    ll pre = 1, ans = 0;
    int k = a.size();
    for (ll i: r) pre *= i;
    for (int i = 0; i < k; ++ i){
        ll m = pre / r[i], x, y;
        exgcd(m, r[i], x, y);  //求逆元
        ans = (ans + a[i] * m * x % pre) % pre;
    }
    return (ans % pre + pre) % pre;
}
```
### 三分法
```c++
double l, r;
const double eps = 1e-6;
while (r - l > eps){
    double mid = (l + r) / 2;
    if (f(mid + eps) > f(mid - eps)) l = mid;
    else r = mid;
}
```
### 卢卡斯定理
求 ${\mathrm{C}}_m^n \bmod{p}$  
注意如果 $p$ 小于 $m$，那么是没法求逆元的
调用一次的时间复杂度为 $\log_{mod}{m}$
```c++
//还是要预处理规模在mod以内的组合数
ll lucas(ll m, ll n){
    return n == 0 ? 1 % mod : lucas(m / mod, n / mod) * cal(m % mod, n % mod) % mod;
}
```
## 图论
### 倍增LCA
```c++
int Log2[MAX], fa[MAX][20], dep[MAX];
//fa的第二维大小不应小于log2(MAX)
bool vis[MAX];
void dfs_lca(int cur, int pre){
    if (vis[cur]) return;
    vis[cur] = true;
    dep[cur] = dep[pre] + 1;
    fa[cur][0] = pre;
    for (int i = 1; i <= Log2[dep[cur]]; ++ i)
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1];
    for (int nex: graph[cur])
        dfs_lca(nex, cur);
}
int lca(int a, int b){
    if (dep[a] > dep[b])
        swap(a, b);
    while (dep[a] != dep[b])
        b = fa[b][Log2[dep[b] - dep[a]]];
    if (a == b)
        return a;
    for (int k = Log2[dep[a]]; k >= 0; k--)
        if (fa[a][k] != fa[b][k])
            a = fa[a][k], b = fa[b][k];
    return fa[a][0];
}
void init_lca(){
    for (int i = 2; i <= n; ++ i)
        Log2[i] = Log2[i / 2] + 1;
    dfs_lca(s, 0); // 无根树可以随意选一点为根
}
```
### SPFA
```c++
vector<vector<pair<int, int>>> graph;
int ans[MAX], cnt[MAX];
bool vis[MAX];
queue<int> que;
bool spfa(int n, int s){
	memset(ans, 0x3f, sizeof(ans));
	ans[s] = 0, vis[s] = 1;
	que.push(s);
	while (!que.empty()){
		int node = que.front();
		que.pop(), vis[node] = 0;
		for (auto edge: graph[node]){
			int ind = edge.second, dist = edge.first;
			if (ans[ind] > ans[node] + dist) {
				ans[ind] = ans[node] + dist;
				cnt[ind] = cnt[node] + 1;  // 记录最短路经过的边数
				if (cnt[ind] >= n) return false;
				// 在不经过负环的情况下，最短路至多经过 n - 1 条边
				// 因此如果经过了多于 n 条边，一定说明经过了负环
				if (!vis[ind]) que.push(ind), vis[ind] = 1;
			}
		}
	}
	return true;
}
```
### dijkstra
```c++
int n, m, s;
int ans[MAX];
bool vis[MAX];
vector<pair<int, int>> graph[MAX]; //边权在后，终点在前
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap;
void dijkstra(int s){
    memset(ans, 0x3f, sizeof ans);
    heap.push({0, s});
    ans[s] = 0;
    while(!heap.empty()){
        auto node = heap.top();
        heap.pop();
        int ind = node.second, dist = node.first;
        if (vis[ind]) continue;
        vis[ind] = 1;
        for (auto edge: graph[ind]){
            int to = edge.first, val = edge.second;
            if (ans[to] > ans[ind] + val){
                ans[to] = ans[ind] + val;
                heap.push({ans[to], to});
            }
        }
    }
}
```
### floyd
```c++
for (int i = 1; i <= n; i ++ ){
    for (int j = 1; j <= n; j ++ ){
        for (int k = 1; k <= n; k ++ ){
            f[j][k] = min(f[j][k], f[j][i] + f[i][k]);
        }
    }
}
```
### 统计三元环数量
```c++
for(int i = 1 ; i <= m ; ++ i) {
    scanf("%d%d", &e[i].u, &e[i].v);
    ++ deg[e[i].u], ++ deg[e[i].v];
}
for(int i = 1 ; i <= m ; ++ i) {
    int u = e[i].u, v = e[i].v;
    if(deg[u] < deg[v] || (deg[u] == deg[v] && u > v)) swap(u, v);
    g[u].push_back(v);
}
for(int x = 1 ; x <= n ; ++ x) {
    for(auto y: g[x]) vis[y] = x;
    for(auto y: g[x])
        for(auto z: g[y])
            if(vis[z] == x)
                ++ ans;
}
```
### prim
```c++
bool vis[MAX];
vector<pair<int, int>> g[MAX];
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap;
void prim(){
    heap.push({0, 1});
    while (!heap.empty()){
        auto node = heap.top(); heap.pop();
        int val = node.first, cur = node.second;
        if (vis[cur]) continue;
        vis[cur] = 1;
        for (auto edge: g[cur])
            if (!vis[edge.second]) heap.push(edge);
        ans += val;
    }
}
``` 
### 拓扑排序
```c++
int n;
vector<vector<int>> graph[MAX];
int in[MAX]; //记录入度的数组
vector<int> topoSort(){
	vector<int> res; //存答案的集合L
	queue<int> que; //存入度为0的点的集合S
	for (int i = 1; i <= n; i ++ )
		if (!in[i]) que.push(i); //先将入度为0的点全部放入S
	while (!que.empty()){
		int node = que.front(); que.pop();
		res.push_back(node); //取出一个点放入L
		for (int nex: graph[node]){
            //删除从这个点起始的所有边，如果删除后终点入度为0，将其放入S
			if (-- in[nex] == 0) que.push(nex);
		}
	}
	if (res.size() == n) return res; //所有点都被取到，排序成功
	else return vector<int>(0); //排序失败，说明这不是一个有向无环图
}
```
### tarjan求强连通分量
```c++
vector<int> graph[MAX]; //图
set<int> nodes[MAX]; //缩后的每个点
int timer = 1, cnt; //时间戳和缩后点的数量
stack<int> stk;
bool instack[MAX]; //是否在栈里
int dfn[MAX], low[MAX]; //dfn表示真实被访问的顺序，low表示可以到达的dfn最小的点
int belong[MAX]; //每个点属于缩后的哪个点
void tarjan(int cur){
	stk.push(cur), instack[cur] = 1;
	dfn[cur] = low[cur] = timer ++;
	for (int nex: graph[cur]){
		if (!dfn[nex]) tarjan(nex), low[cur] = min(low[cur], low[nex]);
        else if (instack[nex]) low[cur] = min(low[cur], dfn[nex]);
	}
	if (dfn[cur] == low[cur]){
		int node = 0; cnt ++;
		while (node != cur){
			node = stk.top(), stk.pop();
            instack[node] = 0;
			belong[node] = cnt;
			nodes[cnt].insert(node);
		}
	}
}

for (int i = 1; i <= n; ++ i){
    if (!dfn[i]) tarjan(i);
}
```
### tarjan割点
对于一个无向图，如果把一个点删除后这个图的连通分量数增加了，那么这个点就是这个图的割点
```c++
vector<int> graph[MAX];
int dfn[MAX], low[MAX], timer, res;
// dfn：记录每个点的时间戳
// low：能不经过父亲到达最小的编号，timer：时间戳，res：答案数量
bool vis[MAX], flag[MAX];  // flag: 答案 vis：标记是否重复
void tarjan2(int cur, int pre) {
    vis[cur] = true;
    low[cur] = dfn[cur] = ++ timer;
    int child = 0;
    for (int nex: graph[cur]){
        if (!vis[nex]){
            child++;
            tarjan2(nex, cur);
            low[cur] = min(low[cur], low[nex]);
            if (pre != cur && low[nex] >= dfn[cur] && !flag[cur]){
                flag[cur] = true;
                res ++;
            }
        }
        else if (nex != pre) low[cur] = min(low[cur], dfn[nex]);
    }
    if (pre == cur && child >= 2 && !flag[cur]){
        flag[cur] = true;
        res ++;
    }
}

for (int i = 1; i <= n; ++ i){
    if (not vis[i]) timer = 0, tarjan2(i, i);
}
```
### tarjan割边
也叫桥，和割点意思差不多
```c++
int low[MAX], dfn[MAX], timer;
bool isbridge[MAX]; //isbridge[x]为真时(fa[x], x)是一条割边
vector<int> graph[MAX];
int cnt;
int fa[MAX];
void tarjan3(int cur, int pre){
    fa[cur] = pre;
    low[cur] = dfn[cur] = ++ timer;
    for (int nex: graph[cur]){
        if (!dfn[nex]){
            tarjan3(nex, cur);
            low[cur] = min(low[cur], low[nex]);
            if (low[nex] > dfn[cur]){
                isbridge[nex] = true;
                cnt ++;
            }
        }
        else if (dfn[nex] < dfn[cur] && nex != pre){
            low[cur] = min(low[cur], dfn[nex]);
        }
    }
}
```
### 增广路算法
设有n个点，m条边，增广路算法可以在 $O(nm)$ 时间内求二分图的最大匹配
```c++
int n, m;
int dfn, res;
vector<int> graph[MAX];
int pa[MAX], pb[MAX], vis[MAX];
bool dfs(int v) {
    vis[v] = dfn;
    for (int u : graph[v]){
        if (pb[u] == -1) {
            pb[u] = v;
            pa[v] = u;
            return true;
        }
    }
    for (int u : graph[v]){
        if (vis[pb[u]] != dfn && dfs(pb[u])){
            pa[v] = u;
            pb[u] = v;
            return true;
        }
    }
    return false;
}
int augment_path(){
    dfn = 0, res = 0;
    for (int i = 0; i < n; ++ i) pa[i] = -1, vis[i] = 0;
    for (int i = 0; i < m; ++ i) pb[i] = -1;
    while (true){
        dfn ++;
        int cnt = 0;
        for (int i = 0; i < n; ++ i){
            if (pa[i] == -1 and dfs(i)){
                cnt++;
            }
        }
        if (cnt == 0){
            break;
        }
        res += cnt;
    }
    return res;
}
```
### 匈牙利算法
作为增广路的一个备胎
```c++
int m, n;            //m, n分别表示左、右侧集合的元素数量
vector<int> graph[MAX]; //存图
int p[MAX];         //记录当前右侧元素所对应的左侧元素
bool vis[MAX];      //记录右侧元素是否已被访问过
bool match(int i){
    for (int j: graph[i])
        if (!vis[j]) //有边且未访问
        {
            vis[j] = true;//记录状态为访问过
            if (p[j] == 0 || match(p[j]))//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            {
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian(){
    int cnt = 0;
    for (int i = 1; i <= m; ++ i){
        memset(vis, 0, sizeof(vis));
        if (match(i)) cnt ++;
    }
    return cnt;
}
```
## 杂项
### 快读快写
```c++
//普通快读更多用于int128
ll read(){
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
//基于fread的高速快读
const int BUFSIZE = 1 << 20;
char ibuf[BUFSIZE], *is = ibuf, *it = ibuf;
inline char getch(){
    if(is == it)
        it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin);
    return is == it ? EOF : *is++;
}
inline int getint(){
    int res = 0, neg = 0, ch = getch();
    while(!(isdigit(ch) or ch == '-') and ch != EOF)
        ch = getch();
    if(ch == '-')
        neg = 1, ch = getch();
    while(isdigit(ch))
        res = res * 10 + (ch - '0'), ch = getch();
    return neg ? -res : res;
}
//普通快写同上
void write(ll x){
    if(x < 0)
        putchar('-'),x = -x;
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
    return;
}
```
### 离散化
```c++
int a[MAX]; // 原数组
int c[MAX], cnt = 0; // 用于离散化的数组，和离散化后最大值的大小
for (int i = 1; i <= n; i ++) c[++ cnt] = a[i];
sort(c + 1, c + cnt + 1);
cnt = unique(c + 1, c + cnt + 1) - c - 1; // 去重，可以跳过此步
for (int i = 1; i <= n; i ++ ) a[i] = lower_bound(c + 1, c + cnt + 1, a[i]) - c;
// c[a[i]] 即为 原始数组中下标为 i 位置的值
```
### 手写哈希表
一般值域比较大的时候会用map来解决问题
因为map的时间复杂度是log的，有时候unordered_map效率也不够，比如P9234这样跑到1e7左右的爆搜
这时候可以尝试一下手写哈希表
```c++
//因为我觉得我永远也不会用到这个东西，所以暂时就这样照抄了
int head[10000005], ky[15000005], nxt[15000005], ccc;
int v[15000005];
const int mod = 9998777;
void ins(int k, int c){
    int id = k%mod;
    ++ccc;
    v[ccc] = c;
    ky[ccc] = k;
    nxt[ccc] = head[id];
    head[id] = ccc;
}
int fd(int x){
    if(x < 0) return -1;
    for(int i = head[x%mod]; i; i = nxt[i]){
        if(ky[i] == x) return i;
    }
    return -1;
}
```
## 结论
### 错排问题
指没有任何元素出现在其有序位置的排列
对于长度为n的排列，错误排列数有 $D_n=(n-1)\cdot(D_{n-1}+D_{n-2})=n\cdot D_{n-1}+(-1)^n$
随着n的增加，取到错排的概率 $P=\lim_{n\to\infty}\frac{D_n}{n!}=\frac{1}{e}$
### 八种球放盒问题
根据球是否相同、盒是否相同、盒是否可以为空分为八种情况  
1.球同，盒不同，不允许空箱子  
$$\begin{cases} C(m-1, n-1), n>=m \\ 
0, n<m \end{cases}$$
2.球同，盒不同，允许空箱子  
$C(n+m-1, m-1)$  
3.球不同，盒同，不允许空箱子
dp[n][m] 表示n个球放在m个盒子，有多少种情况，记作S[n][m]  
dp[n][m] = m*dp[n-1][m] + dp[n-1][m-1]  
初始化：   
dp[i][i] = 1 i>=1  
dp[i][1] = 1 i>=1  
dp[i][j] = 0 i<j  
4.球不同，盒同，允许空箱子
dp[n][m] 表示n个球放在m个盒子，有多少种情况  
dp[n][m] = S[n][1] + S[n][2] + S[n][3] + ... + S[n][m]  
初始化：  
dp[n][1] = 1  
5.球不同，盒不同，不允许空箱子  
dp[m][n] 表示m个盒子装n个球  
dp[m][n] = S[m][n] * m!  
6.球不同，盒不同，允许空箱子  
$m ^ n$  
7.球同，盒同，不允许空箱子  
dp[m][n]记作F[m][n]
dp[1][n-m] + dp[2][n-m] + ... +dp[m][n-m]  
dp[m][n] = dp[1][n-m] + dp[2][n-m] + ... +dp[m][n-m]  
8.球同，盒同，允许空箱子  
dp[m][n] = F[1][n] + F[2][n] + ... +F[m][n]
## 公式
### 积分
$\int_0^{\frac{\pi}{2}}sinx^ndx=\left\{\begin{matrix}{\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{3}{4}\cdot\frac{1}{2}\cdot\frac{\pi}{2},n为奇数}\\{\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{4}{5}\cdot\frac{2}{3}\cdot1,n为偶数}\end{matrix}\right.$  
$\int_0^{\frac{\pi}{2}}cosx^ndx=\left\{\begin{matrix}{\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{3}{4}\cdot\frac{1}{2}\cdot\frac{\pi}{2},n为奇数}\\{\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{4}{5}\cdot\frac{2}{3}\cdot1,n为偶数}\end{matrix}\right.$  
$\sum_{k=1}^{n} k^{2}=1^{2}+2^{2}+3^{2}+\cdots+n^{2}=\frac{n(n+1)(2 n+1)}{6}$  
$\sum_{k=1}^{n} (2k-1)^2=\frac{n(4n^2-1)}{3}$  
$\sum_{k=1}^{n} k^{3}={(\frac{n(n+1)}{2})}^2$  
$S_n=\frac{a_1(1-q^n)}{1-q}$
### 最小环
如果是有向图，对于每一条边，跑dij求出从边的终点到起点的最短路，然后加上这条边的权值，即为含有这条边的最小环的权值。时间复杂度 $O(m(n + m)log)$
如果是无向图，那么转化为有向图
### 树上差分
点差分：要使点 $x$ 、 $y$ 之间的所有点的值加上 $z$，可以令 $d_x += z, d_y += z, d_{lca(x, y)} -= z, d_{pre_{lca(x, y)}} -= z$  
边差分：要使点 $x$ 、 $y$ 之间的所有边的值加上 $z$，可以令 $d_x += z, d_y += z, d_{lca(x, y)} -= 2 * z$
### 差分约束
给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：
$$ \begin{cases} x_{c_1}-x_{c'_1}\leq y_1 \\x_{c_2}-x_{c'_2} \leq y_2 \\ \cdots\\ x_{c_m} - x_{c'_m}\leq y_m\end{cases}$$
的不等式组，求任意一组满足这个不等式组的解。  
对于每一个$x_{i} - x_{j} \leq k$，建立一条从$j$到$i$，权值为$k$的有向边。从点$0$处向每一个点连一条权值为$0$的边，然后在图上从$0$开始跑spfa。如果有负环，那么无解。否则$dist[i]$即为一组解。  
注意如果给解当中的每个元素加上$d$，那么所有的$d$会抵消，仍然是一组解。
### 2-sat
简单的说就是给出 $n$ 个集合，每个集合有两个元素，已知若干个 $\langle a,b \rangle$ ，表示 $a$ 与 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。  
假设有 ${a1,a2}$ 和 ${b1,b2}$ 两对，已知 $a1$ 和 $b2$ 间有矛盾，于是为了方案自洽，由于两者中必须选一个，所以我们就要拉两条有向边 $(a1,b1)$ 和 $(b2,a2)$ 表示选了 $a1$ 则必须选 $b1$ ，选了 $b2$ 则必须选 $a2$ 才能够自洽。  
然后对这个图tarjan求强连通分量。无解的充要条件是存在一对属于同一个集合的点在同一个强连通分量当中。已知有解的前提下，要输出一组解，可以对于每一个集合，输出拓扑序靠前的那一个。因为在tarjan当中求过访问的顺序，因此在我的tarjan板子中，输出每一对点当中belong小的那一个。
